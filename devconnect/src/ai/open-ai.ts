import OpenAI from 'openai'
import fs from 'fs'
import path from 'path'
require('dotenv').config()
import { zodResponseFormat } from "openai/helpers/zod";
import { z } from "zod";
import { loadAndFormatCMS } from './format-content'

const openai = new OpenAI({
  apiKey: process.env.OPEN_AI_KEY,
})

const CMS_PAGES_DIR = path.resolve(__dirname, '../../cms/pages')
const CMS_TRANSLATIONS_DIR = path.resolve(__dirname, '../../cms/global-translations')

const TranslationSchema = z.object({
  output: z.string()
});

// export const aiDisambiguateWord = async (
//   text: string,
//   textLanguage: string
// ) => {
//   const ResponseSchema = z.object({
//     disambiguations: z.array(DisambiguationSchema),
//   });

//   const completion = await openai.beta.chat.completions.parse({
//     model: "gpt-4o-mini",
//     messages: [
//       {
//         role: "system",
//         content: `Users will input words or sentences that need to be translated. Some inputs may have multiple meanings, and your job is to provide users with a list of possible meanings, but ONLY when it makes sense to do so - i.e. it's totally okay to just return one meaning if the difference is not important. E.g. in Japanese, 'は' could be a particle or tooth, and similar situations may occur in other languages.`,
//       },
//       {
//         role: "user",
//         content: `The input is in ${textLanguage}. The input is: ${text}`,
//       },
//     ],
//     response_format: zodResponseFormat(ResponseSchema, "meanings"),
//   });

//   const disambiguations = completion.choices[0].message.parsed;

//   return disambiguations;
// };

export const api = (() => {
  const _interface = {
    // createTranslationAssistant: async () => {
      
    //   const assistant = await openai.beta.assistants.create({
    //     name: 'Devconnect Translation Assistant',
    //     model: 'gpt-4o-mini',
    //     temperature: 0,
    //     instructions: 'You take a markdown file generated by our CMS and translate it to Spanish. Keep the same structure and formatting.',
    //   })

    //   console.log('created translation assistant', assistant)
    // },
    translateContent: async () => {
      // Translate both directories
      await translateDirectory(CMS_PAGES_DIR)
      await translateDirectory(CMS_TRANSLATIONS_DIR)
    },
    // Load CMS data and push to open ai - this is called by a github action triggered on each commit
    prepareContent: async (assistantID: string) => {
      console.log('preparing content')

      await loadAndFormatCMS()

      // Create vector store for website content
      const vectorStore = await openai.beta.vectorStores.create({
        // name: 'Website Content: ' + new Date().toISOString(),
        name: `devconnect_website_${process.env.GITHUB_SHA}`,
      })

      const contentDir = path.resolve(__dirname, 'formatted-content')

      const files = fs.readdirSync(contentDir)

      const fileStreams = files.map((file: string) => {
        const filePath = path.join(contentDir, file)
        return fs.createReadStream(filePath)
      })

      // Upload files to vector store
      await openai.beta.vectorStores.fileBatches.uploadAndPoll(vectorStore.id, { files: fileStreams })
    },
  }

  async function translateDirectory(sourceDir: string) {
    const allEntries = fs.readdirSync(sourceDir)
    const files = allEntries.filter(entry => 
      fs.statSync(path.join(sourceDir, entry)).isFile()
    )

    // Create translation directories if they don't exist
    const esDir = path.join(sourceDir, 'es')
    const ptDir = path.join(sourceDir, 'pt')

    if (!fs.existsSync(esDir)) {
      fs.mkdirSync(esDir, { recursive: true })
    }
    if (!fs.existsSync(ptDir)) {
      fs.mkdirSync(ptDir, { recursive: true })
    }

    for (const file of files) {
      const filePath = path.join(sourceDir, file)
      let content = fs.readFileSync(filePath, 'utf-8')

      let asJSON;
      
      try {
        asJSON = JSON.parse(content)
      } catch (e) {
        asJSON = false
      }

      if (asJSON) {
        content = JSON.stringify(asJSON['global_translations'])
      }

      const spanishCompletion = await openai.beta.chat.completions.parse({
        temperature: 0,
        model: 'gpt-4o',
        messages: [
          { role: 'system', content: 'You take a file generated by our CMS and translate it to Spanish. Keep the exact same structure and formatting. I cannot emphasize this enough. Under no circumstances should your output have ANY structural differentation to the input. Do not include any other text or comments. Do not change or omit *any* field names, and do not translate any values for fields that start with an underscore - e.g. _template, _type, _id, etc.' },
          { role: 'user', content: content }
        ],
        response_format: zodResponseFormat(TranslationSchema, 'output'),
      })

      let { output: spanish } = spanishCompletion.choices[0].message.parsed as any

      const portugueseCompletion = await openai.beta.chat.completions.parse({
        temperature: 0,
        model: 'gpt-4o',
        messages: [
          { role: 'system', content: 'You take a file generated by our CMS and translate it to Portuguese. Keep the exact same structure and formatting. I cannot emphasize this enough. Under no circumstances should your output have ANY structural differentation to the input. Do not include any other text or comments. Do not change or omit *any* field names, and do not translate any values for fields that start with an underscore - e.g. _template, _type, _id, etc.'  },
          { role: 'user', content: content }
        ],
        response_format: zodResponseFormat(TranslationSchema, 'output'),
      })

      let { output: portuguese } = portugueseCompletion.choices[0].message.parsed as any

      if (asJSON) {
        spanish = JSON.stringify({
          'global_translations': spanish
        })

        portuguese = JSON.stringify({
          'global_translations': portuguese
        })
      }
      
      const spanishFilePath = path.join(sourceDir, `es/${file}`)
      fs.writeFileSync(spanishFilePath, spanish)

      const portugueseFilePath = path.join(sourceDir, `pt/${file}`)
      fs.writeFileSync(portugueseFilePath, portuguese)
    }
  }

  return _interface
})()

export default api
