import OpenAI from 'openai'
import fs from 'fs'
import path from 'path'
require('dotenv').config()
import { zodResponseFormat } from "openai/helpers/zod";
import { z } from "zod";
import { loadAndFormatCMS } from './format-content'

const openai = new OpenAI({
  apiKey: process.env.OPEN_AI_KEY,
})

const CMS_PAGES_DIR = path.resolve(__dirname, '../../cms/pages')

const TranslationSchema = z.object({
  translation: z.string(),
});

// export const aiDisambiguateWord = async (
//   text: string,
//   textLanguage: string
// ) => {
//   const ResponseSchema = z.object({
//     disambiguations: z.array(DisambiguationSchema),
//   });

//   const completion = await openai.beta.chat.completions.parse({
//     model: "gpt-4o-mini",
//     messages: [
//       {
//         role: "system",
//         content: `Users will input words or sentences that need to be translated. Some inputs may have multiple meanings, and your job is to provide users with a list of possible meanings, but ONLY when it makes sense to do so - i.e. it's totally okay to just return one meaning if the difference is not important. E.g. in Japanese, 'は' could be a particle or tooth, and similar situations may occur in other languages.`,
//       },
//       {
//         role: "user",
//         content: `The input is in ${textLanguage}. The input is: ${text}`,
//       },
//     ],
//     response_format: zodResponseFormat(ResponseSchema, "meanings"),
//   });

//   const disambiguations = completion.choices[0].message.parsed;

//   return disambiguations;
// };

export const api = (() => {
  const _interface = {
    // createTranslationAssistant: async () => {
      
    //   const assistant = await openai.beta.assistants.create({
    //     name: 'Devconnect Translation Assistant',
    //     model: 'gpt-4o-mini',
    //     temperature: 0,
    //     instructions: 'You take a markdown file generated by our CMS and translate it to Spanish. Keep the same structure and formatting.',
    //   })

    //   console.log('created translation assistant', assistant)
    // },
    translateContent: async () => {
      const verifyTranslation = async (file: string, translation: string) => {
        // load the orginal file and all its fields
        const originalFile = fs.readFileSync(path.join(CMS_PAGES_DIR, file), 'utf-8')
        const originalFields = originalFile.split('\n').filter(line => line.startsWith('_'))
        // load the translated file and all its fields
        const translatedFile = fs.readFileSync(path.join(CMS_PAGES_DIR, `es/${file}`), 'utf-8')
        const translatedFields = translatedFile.split('\n').filter(line => line.startsWith('_'))
        // compare the fields
        return originalFields.every(field => translatedFields.includes(field))
      }

      const allEntries = fs.readdirSync(CMS_PAGES_DIR)
      const files = allEntries.filter(entry => 
        fs.statSync(path.join(CMS_PAGES_DIR, entry)).isFile()
      )

      // Create 'es' directory if it doesn't exist
      const esDir = path.join(CMS_PAGES_DIR, 'es')
      if (!fs.existsSync(esDir)) {
        fs.mkdirSync(esDir, { recursive: true })
      }

      for (const file of files) {
        const filePath = path.join(CMS_PAGES_DIR, file)
        const content = fs.readFileSync(filePath, 'utf-8')

        const completion = await openai.beta.chat.completions.parse({
          temperature: 0,
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: 'You take a .mdx file generated by our CMS and translate it to Danish. Keep the same structure and formatting.' },
            { role: 'user', content: content }
          ],
          response_format: zodResponseFormat(TranslationSchema, 'translation'),
        })

        const translation = completion.choices[0].message.parsed as any
        
        const translatedFilePath = path.join(CMS_PAGES_DIR, `es/${file}`)
        fs.writeFileSync(translatedFilePath, translation.translation)
      }
    },
    // Load CMS data and push to open ai - this is called by a github action triggered on each commit
    prepareContent: async (assistantID: string) => {
      console.log('preparing content')

      await loadAndFormatCMS()

      // Create vector store for website content
      const vectorStore = await openai.beta.vectorStores.create({
        // name: 'Website Content: ' + new Date().toISOString(),
        name: `devconnect_website_${process.env.GITHUB_SHA}`,
      })

      const contentDir = path.resolve(__dirname, 'formatted-content')

      const files = fs.readdirSync(contentDir)

      const fileStreams = files.map((file: string) => {
        const filePath = path.join(contentDir, file)
        return fs.createReadStream(filePath)
      })

      // Upload files to vector store
      await openai.beta.vectorStores.fileBatches.uploadAndPoll(vectorStore.id, { files: fileStreams })
    },
  }

  return _interface
})()

export default api
